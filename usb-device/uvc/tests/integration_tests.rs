use std::time::Duration;use tokio::time;use crab_usb::USBHost;use usb_uvc::{UvcDevice, VideoControlEvent, UvcDeviceState};/// Integration test - requires a real UVC device connected/// Make sure a USB camera is connected to the system before running#[tokio::test]#[ignore] // Ignored by default, run manuallyasync fn test_uvc_device_integration() -> Result<(), Box<dyn std::error::Error>> {    env_logger::init();    // Create USB host    let mut host = USBHost::new_libusb();        // Scan devices    let devices = host.device_list().await?;    assert!(!devices.is_empty(), "No USB devices found");    // Find UVC device    let mut uvc_device = None;    for mut device_info in devices {        if UvcDevice::check(&device_info) {            let device = device_info.open().await?;            uvc_device = Some(UvcDevice::new(device).await?);            break;        }    }    let mut uvc = uvc_device.expect("No UVC device found. Please connect a USB camera.");    // Test initial device state    assert_eq!(*uvc.get_state(), UvcDeviceState::Configured);    assert!(uvc.get_current_format().is_none());    // Test device info    let device_info = uvc.get_device_info().await?;    assert!(!device_info.is_empty());    // Test supported formats    let formats = uvc.get_supported_formats().await?;    assert!(!formats.is_empty(), "Device should support at least one format");    // Test format setting    let first_format = formats.first().unwrap().clone();    uvc.set_format(first_format.clone()).await?;    assert_eq!(uvc.get_current_format(), Some(&first_format));    // Test control commands    uvc.send_control_command(VideoControlEvent::BrightnessChanged(100)).await?;    uvc.send_control_command(VideoControlEvent::ContrastChanged(50)).await?;    // Test start streaming    uvc.start_streaming().await?;    assert_eq!(*uvc.get_state(), UvcDeviceState::Streaming);    // Test receiving a few frames    let mut frame_count = 0;    let start_time = std::time::Instant::now();        while frame_count < 5 && start_time.elapsed() < Duration::from_secs(10) {        match uvc.recv_frame().await {            Ok(Some(frame)) => {                frame_count += 1;                assert!(!frame.data.is_empty(), "Frame data should not be empty");                assert_eq!(frame.format, first_format);                                if frame.end_of_frame {                    println!("Received complete frame {}: {} bytes", frame_count, frame.data.len());                }            }            Ok(None) => {                // No complete frame, continue waiting                time::sleep(Duration::from_millis(1)).await;            }            Err(e) => {                eprintln!("Error receiving frame: {:?}", e);                time::sleep(Duration::from_millis(10)).await;            }        }    }    assert!(frame_count > 0, "Should have received at least one frame");    // Test stop streaming    uvc.stop_streaming().await?;    assert_eq!(*uvc.get_state(), UvcDeviceState::Configured);    Ok(())}#[tokio::test]#[ignore]async fn test_uvc_error_handling() -> Result<(), Box<dyn std::error::Error>> {    let mut host = USBHost::new_libusb();    let devices = host.device_list().await?;        let mut uvc_device = None;    for mut device_info in devices {        if UvcDevice::check(&device_info) {            let device = device_info.open().await?;            uvc_device = Some(UvcDevice::new(device).await?);            break;        }    }    let mut uvc = uvc_device.expect("No UVC device found");    // Test starting streaming without format    let result = uvc.start_streaming().await;    assert!(result.is_err(), "Should fail when no format is set");    // Set format and test again    let formats = uvc.get_supported_formats().await?;    let format = formats.first().unwrap().clone();    uvc.set_format(format).await?;        // Now should be able to start streaming    uvc.start_streaming().await?;    assert_eq!(*uvc.get_state(), UvcDeviceState::Streaming);    // Test receiving frames    let frame_result = uvc.recv_frame().await;    // This may succeed or fail depending on device state, but should not crash    uvc.stop_streaming().await?;    Ok(())}